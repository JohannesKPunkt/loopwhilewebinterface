\headline { Online Loop/While Interpreter }

\tableofcontents

\chapter { Syntax und Semantik }
    Die hier verwendete Loop/While-Sprache folgt der Syntax von M. Gebhard \link{#cite1}{[1]}.
    \section { Basiskonstrukte }
        Zu Beginn eines Programms werden die Ein- und Ausgabeparameter durch
        die Schlüsselwörter \italic{in} und \italic{out} festgelegt.
        Mit \italic{aux} können zusätzliche Hilfsvariablen deklariert werden.
        Alle Variablen sind vom Typ der natürlichen Zahlen. Es stehen neben der Vorgänger-
        und Nachfolgeroperation \italic {succ} und \italic { pred } die
        arithmetischen Operatoren \italic {+}, \italic {-}, \italic {*},
        \italic {div} und \italic {mod} zur Verfügung.
    \linebreak
        Das nachfolgende Beispielprogramm liest einen Wert \italic{input} von
        der Eingabe, verdoppelt ihn und gibt ihn anschließend auf der Konsole aus:
    \linebreak

    \code{
in: input;
out: output;

output := 2 * input;
    }

    \linebreak
        Die Vergleichsoperatoren \italic{<}, \italic{<=},
        \italic{==}, \italic{!=}, \italic{>=},
        \italic{>} liefern als Ergebnis 1, wenn sie zu wahr, und 0,
        wenn sie zu falsch evaluiert werden.
    \linebreak
        Das Programm im nachfolgenden Beispiel gibt aus, ob die Eingabe gerade
        ist oder nicht:

    \code{
in: input;
out: output;

output := input mod 2;
    }
    
    \section { if-then-else }

            Das einfachste Kontrollkonstrukt ist die Fallunterscheidung.
        \linebreak
        \code {
in: x;
out: y;

if x != 0 then
    // then-Teil
else
    // else-Teil
endif
        }

            Wenn die Bedingung x != 0 zutrifft, wird der Code im then-Teil ausgeführt,
            andernfalls der Code im else-Teil. Die LOOP/WHILE-Sprache ermöglicht nur
            den Vergleich, ob Variablen ungleich 0 sind. Andere Vergleiche können
            durch die Verwendung von Hilfsvariablen erreicht werden. Im nächsten
            Beispiel wird z.B. verglichen, ob die Eingabe x größer als 42 ist.
            Dabei ist zu beachten, dass die Subtraktionsoperation auf natürlichen
            Zahlen abschneidet, d.h. \nobr{x-y = 0}, falls \html{<span style="white-space: nowrap;">y &ge; x</span>}.
        \linebreak
        \code {
in: x;
out: y;
aux: tmp;

tmp := x - 42;
if tmp != 0 then
    // Wird ausgeführt, wenn x > 42 ist
    y := 1;
else
    y := 0;
endif
        }

    \section { while-Schleifen }
            Um Anweisungen wiederholt auszuführen, sind i.A. Schleifenkonstrukte wie
            die while-Schleife nötig. Deren Schleifenkörper wird nur betreten, falls
            die Schleifenbedingung \html{<span style="white-space: nowrap;">x &ne; 0</span>} erfüllt ist, und solange wiederholt ausgeführt,
            bis die Bedingung am Ende eines Durchlaufs nicht mehr zutrifft.
        \linebreak
        \code {
in: x;
out: y;

while x != 0 do
    // Schleifenkörper
enddo
}
        \linebreak
        Die bisher beschriebene Teilmenge der Loop/While-Sprache ist bereits Turing-Mächtig,
        d.h. für jedes berechenbare Problem existiert auch ein Algorithmus in dieser Sprache
        \link{#cite2}{[2]}.
    
    \section { loop-Schleifen }
            Ein anderes Schleifenkonstrukt ist die loop-Schleife. Die Schleife
            \code {
in: x;
out: y;

loop x do
    // Schleifenkörper
enddo
            }
            wird genau so oft ausgeführt wie der Wert der Variablen x beim Eintritt in die Schleife.
            Das hat insbesondere zur Folge, dass Modifikationen dieser Variablen im Schleifenkörper die
            Anzahl der Schleifendurchläufe nicht beeinflusst.
            \linebreak
            Jede solche loop-Schleife kann durch eine äquivalente while-Schleife ersetzt werden, jedoch
            gilt die Umkehrung dieser Aussage nicht, was zur Folge hat, dass die Loop/While-Sprache ohne while-Schleifen
            nicht Turing-Mächtig (sondern lediglich gleichmächtig zur Primitiven Rekursion ist) \link{#cite2}{[2]}.
            \linebreak
            Um sicherzustellen, dass das vorliegende Programm nur loop-Schleifen
            verwenden darf, kann am Anfang des Programms das Sprachflag #LOOP
            gesetzt werden.
        \linebreak
        \code{
#LOOP
in: x, y;
out: z;

//[...]
        }
        
    \section {Makros}
        Makros ermöglichen die strukturierte Programmierung, indem gemeinsamer Code ausgelagert wird.
        Eine Makrodefinition besteht dabei aus dem Namen, der Deklaration der Eingangs-, Ausgangs-
        und Hilfsvariablen, sowie dem Code des Makros selbst. Alle Makros müssen noch vor den Parametern
        des Hauptprogramms definiert werden. Rekursion von Makros ist dabei nicht erlaubt.
    \linebreak
        Das folgende Beispiel demonstriert ein Makro \italic {multiply}, das die Multiplikation
        zweier natürlicher Zahlen realisiert:
    \linebreak
    \linebreak

    \code {
def multiply
  in: x, y;
  out: z;
  
  z := 0;
  loop x do
    z := z + y;
  enddo
enddef;

in: x, y;
out: z;
z := multiply(x, y)
    }


\chapter { Editor und Interpreter }
        Über das Editorfenster links oben können Loop/While Programme editiert werden.
        Der Editor bietet eine auf regulären Ausdrücken basierende farbige Syntaxhervorhebung,
        copy-and-paste Funktionalität über die gewohnten Tastenkombinationen des verwendeten
        Betriebssystems, sowie die Möglichkeit einer Vollbilddarstellung durch drücken der Taste
        F11.
    \linebreak
    \linebreak
        Über das Terminalfenster links unten wird die Ausgabe des Interpreters dargestellt und
        Nutzereingaben entgegengenommen.
    \linebreak
    \linebreak
        Editor und Interpreter können über die graue Menüleiste oberhalb des Editorfensters
        gesteuert werden, wie in nachfolgender Tabelle erklärt wird:
    \linebreak
    \linebreak
    \html {
        <table class="tutorialContainerTable">
        <tr><td><img src="img/icons/baseline_play_arrow_black_24dp.png" /></td>
            <td>Startet den Interpreter</td></tr>
        <tr><td><img src="img/icons/baseline_bug_report_black_24dp.png" /></td>
            <td>Startet eine neue Debuggersitzung</td></tr>
        <tr><td><img src="img/icons/baseline_undo_black_24dp.png" /></td>
            <td>Macht die letzte Eingabe in das Editorfenster r&uuml;ckg&auml;ngig</td></tr>
        <tr><td><img src="img/icons/baseline_redo_black_24dp.png" /></td>
            <td>Wiederholt die letzte Eingabe in das Editorfenster</td></tr>
        <tr><td><img src="img/icons/baseline_folder_open_black_24dp.png" /></td>
            <td>&Ouml;ffnet eine lokale Datei und l&auml;dt sie in das Editorfenster</td></tr>
        <tr><td><img src="img/icons/baseline_save_black_24dp.png" /></td>
            <td>Speichert den aktuellen Inhalt des Editorfensters in eine lokale Datei</td></tr>
        </table>
    }

\chapter { Debugging}
    Nachdem in die Debuggeransicht gewechselt wurde, können Breakpoints durch klicken neben
    die entsprechende Zeilennummer gesetzt und wieder entfernt werden. Nachdem der Debugger
    gestartet und die Startparameter über das Terminalfenster belegt wurden, wird die Ausführung
    des Programms unterbrochen, sobald ein Breakpoint erreicht wurde. Die Ausführung kann dann
    entweder Schritt für Schritt weitergeführt oder direkt bis zum nächsten Breakpoint fortgesetzt
    werden. Die Steuerung des Debuggers erfolgt analog zum Interpretermodus über die Menüleiste (siehe
    Tabelle unten). An Stelle des Terminalfensters erscheint während der Programmausführung eine Auflistung
    aller Variablenwerte.

\linebreak
\linebreak
\html {
        <table class="tutorialContainerTable">
        <tr><td><img src="img/icons/baseline_skip_next_black_24dp.png" /></td>
            <td>F&uuml;hrt die Ausf&uuml;hrung des Debuggers bis zum Erreichen des n&auml;chsten Breakpoints fort</td></tr>
        <tr><td><img src="img/icons/baseline_call_missed_black_24dp.png" style="transform:rotate(180deg);" /></td>
            <td>F&uuml;hrt einen Schritt des Debuggers aus, &uuml;berspringt aber Aufrufe von Makros</td></tr>
        <tr><td><img src="img/icons/baseline_vertical_align_bottom_black_24dp.png" /></td>
            <td>F&uuml;hrt einen Schritt des Debuggers aus</td></tr>
        <tr><td><img src="img/icons/baseline_vertical_align_top_black_24dp.png" /></td>
            <td>Springt aus dem aktuellen Makro zur&uuml;ck an die Aufrufstelle</td></tr>
        <tr><td><img src="img/icons/baseline_close_black_24dp.png" /></td>
            <td>Beendet die aktuelle Debuggersitzung und wechselt zur Interpreteransicht zur&uuml;ck</td></tr>
        </table>
    }

\chapter{Literatur}
    \html{<span id="cite1">[1] Michael Gebhard. <a href="https://www8.cs.fau.de/_media/tools:thesis22NOvfinal.pdf">Development
        of a Programming Environment and Interpreter for LOOP and WHILE.</a>
        Bachelor Thesis in Computer Science. Friedrich-Alexander Universität Erlangen-Nürnberg, 2018.</span>}
    \html{<span id="cite2">[2] Dirk W. Hoffmann. Theoretische Informatik. Carl Hanser Verlag, München, 2018.</span>}
